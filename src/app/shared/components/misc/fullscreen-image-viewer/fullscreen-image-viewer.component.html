<ng-template #hdImageLoadingTemplate>
  <div *ngIf="hdThumbnailLoading" class="loading-indicator-container has-message">
    <astrobin-loading-indicator></astrobin-loading-indicator>
  </div>
</ng-template>

<ng-template #realThumbnailLoadingTemplate>
  <div *ngIf="realThumbnailLoading" class="loading-indicator-container has-message">
    <astrobin-loading-indicator [progress]="realImageLoadingProgress$ | async"></astrobin-loading-indicator>
  </div>
</ng-template>

<ng-template #instructionTemplate let-message="message" let-icon="icon">
  <div class="instruction-container">
    <div class="instructions">
      <fa-icon [icon]="icon"></fa-icon>
      <span [innerHTML]="message"></span>
    </div>
  </div>
</ng-template>

<ng-template #fullSizeLimitationTemplate>
  <ng-container
    [ngTemplateOutlet]="instructionTemplate"
    [ngTemplateOutletContext]="{
      icon: 'info-circle',
      message: 'Zoom disabled by the image owner.' | translate
    }"
  ></ng-container>
</ng-template>

<ng-template #imageTooLargeToZoomTemplate>
  <ng-container
    [ngTemplateOutlet]="instructionTemplate"
    [ngTemplateOutletContext]="{
      icon: 'warning',
      message: ('Image too large for the interactive zoom.' | translate) + ' ' + ('Click to view full size in a new tab.' | translate)
    }"
  ></ng-container>
</ng-template>

<ng-template #gifNoZoomTemplate>
  <ng-container
    [ngTemplateOutlet]="instructionTemplate"
    [ngTemplateOutletContext]="{
      icon: 'info-circle',
      message: 'Zooming is not available for GIF animations on touch devices.' | translate
    }"
  ></ng-container>
</ng-template>

<ng-template #pinchAndZoomInstructionTemplate>
  <ng-container
    [ngTemplateOutlet]="instructionTemplate"
    [ngTemplateOutletContext]="{
      icon: 'hand-paper',
      message: 'Pinch and zoom!' | translate
    }"
  ></ng-container>
</ng-template>

<ng-template #clickAndScrollInstructionTemplate>
  <ng-container
    [ngTemplateOutlet]="instructionTemplate"
    [ngTemplateOutletContext]="{
      icon: 'mouse-pointer',
      message: 'Scroll to magnify.' | translate
    }"
  ></ng-container>
</ng-template>

<ng-template #clickAgainToCloseLensInstructionTemplate>
  <ng-container
    [ngTemplateOutlet]="instructionTemplate"
    [ngTemplateOutletContext]="{
        icon: 'mouse-pointer',
        message: 'Click again to close lens.' | translate
      }"
  ></ng-container>
</ng-template>

<ng-template #zoomFrozenInstructionTemplate>
  <ng-container
    [ngTemplateOutlet]="instructionTemplate"
    [ngTemplateOutletContext]="{
        icon: 'lock',
        message: 'Zoom is frozen. Press F to unfreeze.' | translate
      }"
  ></ng-container>
</ng-template>

<ng-template #measureFirstPointInstructionTemplate>
  <ng-container
    [ngTemplateOutlet]="instructionTemplate"
    [ngTemplateOutletContext]="{
        icon: 'mouse-pointer',
        message: 'Click on first point to begin measurement.' | translate
      }"
  ></ng-container>
</ng-template>

<ng-template #measureSecondPointInstructionTemplate>
  <ng-container
    [ngTemplateOutlet]="instructionTemplate"
    [ngTemplateOutletContext]="{
        icon: 'mouse-pointer',
        message: 'Click on second point to complete measurement.' | translate
      }"
  ></ng-container>
</ng-template>

<ng-template #touchDeviceTemplate let-hd="hd" let-real="real">
  <div class="touch-device">
    <div
      class="loading-indicator-container has-message"
      *ngIf="!isVeryLargeImage && (hdThumbnailLoading || realThumbnailLoading || canvasLoading)"
    >
      <astrobin-loading-indicator [progress]="loadingProgress$ | async"></astrobin-loading-indicator>
    </div>

    <ng-container *ngIf="!isVeryLargeImage">
      <!-- For GIFs, show a simple image without zooming capabilities -->
      <div *ngIf="isGif && real && allowReal" @fadeInOut class="gif-container">
        <img
          [src]="realThumbnailUnsafeUrl"
          alt=""
          class="gif-image"
        />
      </div>

      <!-- For regular images, use the canvas-based zoom -->
      <div
        *ngIf="!isGif && real && allowReal"
        @fadeInOut
        #touchRealContainer
        class="touch-real-container"
        (pinchstart)="onPinchStart($event)"
        (pinchmove)="onPinchMove($event)"
        (pinchend)="onPinchEnd()"
        (panstart)="onPanStart($event)"
        (panmove)="onPanMove($event)"
        (panend)="onPanEnd($event)"
        (doubletap)="onDoubleTap($event)"
      >
        <canvas #touchRealCanvas class="touch-real-canvas"></canvas>

        <div
          *ngIf="actualTouchZoom !== null && !canvasLoading"
          class="touch-zoom-indicator"
          [class.beyond-one]="Math.round(actualTouchZoom * 100) >= 101"
          (mouseenter)="setMouseOverUIElement(true)"
          (mouseleave)="setMouseOverUIElement(false)"
        >
          {{ actualTouchZoom | number:'1.2-2' }}x
        </div>
      </div>
    </ng-container>

    <ng-container *ngIf="isVeryLargeImage">
      <img
        *ngIf="!real"
        [src]="hd"
        alt=""
        class="hd-image"
      />

      <a
        *ngIf="hd && real && realThumbnailUnsafeUrl"
        [href]="realThumbnailUnsafeUrl"
        class="no-external-link-icon d-flex align-items-center"
        target="_blank"
      >
        <img
          [src]="hd"
          alt=""
          class="hd-image"
        />
      </a>
      <ng-container
        *ngIf="hd && real && allowReal && realThumbnailUnsafeUrl"
        [ngTemplateOutlet]="imageTooLargeToZoomTemplate"
      ></ng-container>
    </ng-container>

    <!-- Show appropriate messages based on image type -->
    <ng-container *ngIf="isGif && allowReal && real"
                  [ngTemplateOutlet]="gifNoZoomTemplate"></ng-container>
    <ng-container *ngIf="!isGif && !isVeryLargeImage && allowReal && real && !canvasLoading"
                  [ngTemplateOutlet]="pinchAndZoomInstructionTemplate"></ng-container>
    <ng-container *ngIf="hd && !allowReal"
                  [ngTemplateOutlet]="fullSizeLimitationTemplate"></ng-container>
  </div>

  <ng-container [ngTemplateOutlet]="zoomModesTemplate" [ngTemplateOutletContext]="{ real }"></ng-container>
</ng-template>

<ng-template #nonTouchDeviceTemplate let-hd="hd" let-real="real">
  <div class="position-relative w-100 h-100 d-flex justify-content-center align-items-center">
    <ng-container *ngIf="!hd && !real" [ngTemplateOutlet]="hdImageLoadingTemplate"></ng-container>
    <ng-container *ngIf="hd && !real && allowReal" [ngTemplateOutlet]="realThumbnailLoadingTemplate"></ng-container>

    <ng-container *ngIf="!isVeryLargeImage">
      <img
        *ngIf="hd && (!real || !allowReal)"
        [src]="hd"
        class="hd-image"
        alt=""
        [style.max-width.px]="naturalWidth"
      />

      <!-- For GIFs on non-touch devices, we can use ngx-image-zoom as it works well there -->
      <lib-ngx-image-zoom
        #ngxImageZoom
        *ngIf="real && allowReal"
        (zoomPosition)="setZoomPosition($event)"
        (zoomScroll)="setZoomScroll($event)"
        (imagesLoaded)="onImagesLoaded($event)"
        [circularLens]="true"
        [enableLens]="enableLens"
        [enableScrollZoom]="true"
        [fullImage]="real"
        [lensHeight]="zoomLensSize"
        [lensWidth]="zoomLensSize"
        [maxZoomRatio]="maxZoom"
        [thumbImage]="hd"
        [scrollStepSize]=".05"
        [zoomMode]="enableLens ? 'toggle-click' : 'click'"
        class="image-zoom"
        [class.lens-enabled]="enableLens"
        [class.zooming-enabled]="zoomingEnabled"
        [class.zoom-frozen]="zoomFrozen"
      >
      </lib-ngx-image-zoom>

      <div
        *ngIf="!isMeasuringMode"
        class="image-zoom-indicator"
        [class.beyond-one]="Math.round(zoomScroll * 100) >= 101"
        [class.frozen]="zoomFrozen"
        (mouseenter)="setMouseOverUIElement(true)"
        (mouseleave)="setMouseOverUIElement(false)"
      >
        <a (click)="snapTo1x()" href="#" astrobinEventPreventDefault>
          {{ zoomScroll | number: "1.2-2" }}x
          <fa-icon
            *ngIf="zoomFrozen"
            icon="lock"
            class="ms-1"
            ngbTooltip="{{ 'Zoom is frozen (F)' | translate }}"
          ></fa-icon>
        </a>
      </div>
    </ng-container>

    <ng-container *ngIf="isVeryLargeImage">
      <img
        *ngIf="!real"
        [src]="hd"
        alt=""
        class="hd-image"
        [style.max-width.px]="naturalWidth"
      />

      <a
        *ngIf="hd && real && realThumbnailUnsafeUrl"
        [href]="realThumbnailUnsafeUrl"
        class="no-external-link-icon d-flex align-items-center"
        target="_blank"
      >
        <img
          [src]="hd"
          alt=""
          class="hd-image"
          [style.max-width.px]="naturalWidth"
        />
      </a>
      <ng-container
        *ngIf="hd && real && allowReal && realThumbnailUnsafeUrl"
        [ngTemplateOutlet]="imageTooLargeToZoomTemplate"
      ></ng-container>
    </ng-container>

    <ng-container
      *ngIf="hd && !allowReal"
      [ngTemplateOutlet]="fullSizeLimitationTemplate"
    ></ng-container>

    <ng-container *ngIf="!isVeryLargeImage && real && allowReal">
      <!-- Zoom-related instructions -->
      <ng-container *ngIf="!isMeasuringMode">
        <ng-container
          *ngIf="zoomFrozen"
          [ngTemplateOutlet]="zoomFrozenInstructionTemplate"
        ></ng-container>

        <ng-container
          *ngIf="!zoomFrozen && !zoomingEnabled && !showZoomIndicator && !isMeasuringMode"
          [ngTemplateOutlet]="clickAndScrollInstructionTemplate"
        ></ng-container>

        <ng-container
          *ngIf="!zoomFrozen && zoomingEnabled && !showZoomIndicator && enableLens && !isMeasuringMode"
          [ngTemplateOutlet]="clickAgainToCloseLensInstructionTemplate"
        ></ng-container>
      </ng-container>

      <!-- Measurement instructions -->
      <ng-container *ngIf="isMeasuringMode">
        <ng-container
          *ngIf="!measureStartPoint"
          [ngTemplateOutlet]="measureFirstPointInstructionTemplate"
        ></ng-container>

        <ng-container
          *ngIf="measureStartPoint && !measureEndPoint"
          [ngTemplateOutlet]="measureSecondPointInstructionTemplate"
        ></ng-container>
      </ng-container>
    </ng-container>
  </div>

  <ng-container [ngTemplateOutlet]="zoomModesTemplate" [ngTemplateOutletContext]="{ real }"></ng-container>
</ng-template>

<ng-template #zoomModesTemplate let-real="real">
  <div
    *ngIf="(!isVeryLargeImage && allowReal && !!real) &&
           (isHybridPC || !isTouchDevice || (isHybridPC && !touchMode))"
    class="zoom-modes"
  >
    <!-- Measuring tool controls (moved to the right side) -->
    <div *ngIf="isMeasuringMode" class="measuring-controls-right"
         (mouseenter)="setMouseOverUIElement(true)"
         (mouseleave)="setMouseOverUIElement(false)">
      <button class="btn btn-sm btn-outline-light me-2" (click)="clearAllMeasurements()"
              *ngIf="previousMeasurements.length > 0">
        <fa-icon icon="trash" class="me-1"></fa-icon>
        {{ 'Clear all' | translate }}
      </button>
      <button class="btn btn-sm btn-outline-light" (click)="toggleMeasuringMode($event)">
        <fa-icon icon="times" class="me-1"></fa-icon>
        {{ 'Exit measuring tool' | translate }}
      </button>
    </div>

    <!-- Kebab menu button - hidden during measuring mode -->
    <div class="kebab-menu-container" *ngIf="!isMeasuringMode"
         (mouseenter)="setMouseOverUIElement(true)"
         (mouseleave)="setMouseOverUIElement(false)">
      <button class="kebab-button" (click)="toggleKebabMenu($event)" [attr.aria-expanded]="showKebabMenu">
        <fa-icon icon="ellipsis-vertical"></fa-icon>
      </button>

      <!-- Dropdown menu -->
      <div class="kebab-dropdown" [class.show]="showKebabMenu">
        <!-- Keyboard shortcuts button - hide on touch devices -->
        <div
          *ngIf="!isTouchDevice"
          class="kebab-menu-item"
          (click)="showShortcutsDialog($event)"
        >
          <fa-icon icon="keyboard"></fa-icon>
          <span>{{ "Keyboard shortcuts" | translate }}</span>
        </div>

        <div *ngIf="!isTouchDevice" class="dropdown-divider"></div>

        <!-- Touch/Mouse mode toggle -->
        <div
          *ngIf="isHybridPC && !isGif"
          class="kebab-menu-item"
          (click)="setTouchMouseMode(!touchMode); toggleKebabMenu($event)"
        >
          <ng-container *ngIf="touchMode">
            <fa-icon icon="hand-pointer"></fa-icon>
            <span>{{ "Touch mode" | translate }}</span>
          </ng-container>
          <ng-container *ngIf="!touchMode">
            <fa-icon icon="mouse-pointer"></fa-icon>
            <span>{{ "Mouse mode" | translate }}</span>
          </ng-container>
        </div>

        <!-- Lens/Zoom mode toggle -->
        <div
          *ngIf="!touchMode"
          class="kebab-menu-item"
          (click)="toggleEnableLens($event); toggleKebabMenu($event)"
        >
          <ng-container *ngIf="enableLens">
            <fa-icon icon="expand"></fa-icon>
            <span>{{ "Zoom mode" | translate }}</span>
          </ng-container>
          <ng-container *ngIf="!enableLens">
            <fa-icon icon="magnifying-glass"></fa-icon>
            <span>{{ "Lens mode" | translate }}</span>
          </ng-container>
        </div>

        <!-- Coordinates toggle - only visible for images with advanced solution -->
        <div
          *ngIf="!isGif && hasAdvancedSolution"
          class="kebab-menu-item"
          (click)="toggleCoordinates(); toggleKebabMenu($event)"
          [class.disabled]="enableLens && zoomingEnabled"
        >
          <fa-icon icon="crosshairs"></fa-icon>
          <span>{{ (showCoordinates ? 'Hide coordinates' : 'Show coordinates') | translate }}</span>
        </div>

        <!-- Measuring tool toggle - available for all images -->
        <div
          *ngIf="!isGif"
          class="kebab-menu-item"
          (click)="toggleMeasuringMode($event); toggleKebabMenu($event)"
          [class.disabled]="enableLens && zoomingEnabled"
          [class.active]="isMeasuringMode"
        >
          <fa-icon icon="ruler"></fa-icon>
          <span>{{ (isMeasuringMode ? 'Cancel measurement' : 'Measure distance') | translate }}</span>
        </div>
      </div>
    </div>
  </div>
</ng-template>

<div
  *ngIf="show"
  @fadeInOut
  [class.touch]="touchMode"
  [class.measuring-mode]="isMeasuringMode"
  class="fullscreen-image-viewer h-100"
  (touchstart)="onTouchStart($event)"
  (touchmove)="onTouchMove($event)"
  (touchend)="onTouchEnd($event)"
  (wheel)="onGlobalWheel($event)"
  (mousemove)="onGlobalMouseMove($event)"
  (mouseleave)="clearCoordinates()"
>
  <!-- Measuring tool -->
  <div class="measuring-tool-container" *ngIf="isMeasuringMode || measureDistance">
    <!-- Start and end markers -->
    <div *ngIf="measureStartPoint" class="measure-marker start-marker"
         [class.dragging]="isDraggingPoint === 'start'"
         [style.left.px]="measureStartPoint.x" [style.top.px]="measureStartPoint.y"
         (mousedown)="handlePointDragStart($event, 'start')">
      <div class="marker-dot"></div>
      <!-- Start point coordinates that will be visible while selecting end point -->
      <div *ngIf="!measureEndPoint" class="marker-coordinates top-position"
           [class.visible]="measureStartPoint.ra !== null"
           style="margin-top: -35px;">
        <small>{{ measureStartPoint.ra !== null ? formatCoordinatesCompact(measureStartPoint.ra, measureStartPoint.dec) : '' }}</small>
      </div>

      <!-- Once both points are selected, calculate perpendicular position for labels -->
      <div *ngIf="measureEndPoint" class="marker-coordinates"
           [class.visible]="measureStartPoint.ra !== null"
           [style.left.px]="calculateStartLabelX()"
           [style.top.px]="calculateStartLabelY()">
        <small>{{ measureStartPoint.ra !== null ? formatCoordinatesCompact(measureStartPoint.ra, measureStartPoint.dec) : '' }}</small>
      </div>
    </div>

    <div *ngIf="measureEndPoint" class="measure-marker end-marker"
         [class.dragging]="isDraggingPoint === 'end'"
         [style.left.px]="measureEndPoint.x" [style.top.px]="measureEndPoint.y"
         (mousedown)="handlePointDragStart($event, 'end')">
      <div class="marker-dot"></div>
      <!-- End point coordinates perpendicular to line -->
      <div class="marker-coordinates"
           [class.visible]="measureEndPoint.ra !== null"
           [style.left.px]="calculateEndLabelX()"
           [style.top.px]="calculateEndLabelY()">
        <small>{{ measureEndPoint.ra !== null ? formatCoordinatesCompact(measureEndPoint.ra, measureEndPoint.dec) : '' }}</small>
      </div>
    </div>

    <!-- Previous lines -->
    <svg class="measure-line-container"
         [attr.width]="isBrowser ? windowRef.nativeWindow.innerWidth : 0"
         [attr.height]="isBrowser ? windowRef.nativeWindow.innerHeight : 0">
      <!-- Previous measurements -->
      <g *ngFor="let measurement of previousMeasurements; let i = index">
        <line
          [attr.x1]="measurement.startX" [attr.y1]="measurement.startY"
          [attr.x2]="measurement.endX" [attr.y2]="measurement.endY"
          class="measure-line previous-line">
        </line>
      </g>

      <!-- Current measurement line -->
      <line *ngIf="!measureEndPoint && measureStartPoint && mouseX !== null && mouseY !== null"
            [attr.x1]="measureStartPoint.x" [attr.y1]="measureStartPoint.y"
            [attr.x2]="mouseX" [attr.y2]="mouseY"
            class="measure-line measuring"></line>
      <line *ngIf="measureEndPoint"
            [attr.x1]="measureStartPoint.x" [attr.y1]="measureStartPoint.y"
            [attr.x2]="measureEndPoint.x" [attr.y2]="measureEndPoint.y"
            class="measure-line current-line"></line>
            
      <!-- Visual indicator for original position when dragging current measurement points -->
      <g *ngIf="isDraggingPoint === 'start' && measureStartPoint">
        <circle
          [attr.cx]="dragStartX || measureStartPoint.x"
          [attr.cy]="dragStartY || measureStartPoint.y"
          r="5"
          class="measure-point original-position">
        </circle>
        <line
          [attr.x1]="dragStartX || measureStartPoint.x"
          [attr.y1]="dragStartY || measureStartPoint.y"
          [attr.x2]="measureStartPoint.x"
          [attr.y2]="measureStartPoint.y"
          class="measure-line drag-indicator">
        </line>
      </g>
      
      <g *ngIf="isDraggingPoint === 'end' && measureEndPoint">
        <circle
          [attr.cx]="dragStartX || measureEndPoint.x"
          [attr.cy]="dragStartY || measureEndPoint.y"
          r="5"
          class="measure-point original-position">
        </circle>
        <line
          [attr.x1]="dragStartX || measureEndPoint.x"
          [attr.y1]="dragStartY || measureEndPoint.y"
          [attr.x2]="measureEndPoint.x"
          [attr.y2]="measureEndPoint.y"
          class="measure-line drag-indicator">
        </line>
      </g>
      
      <!-- Visual indicators for dragging previous measurement points -->
      <g *ngFor="let measurement of previousMeasurements; let i = index">
        <!-- Start point drag indicator -->
        <g *ngIf="isDraggingPoint === 'prevStart-' + i">
          <circle
            [attr.cx]="dragStartX || measurement.startX"
            [attr.cy]="dragStartY || measurement.startY"
            r="5"
            class="measure-point original-position">
          </circle>
          <line
            [attr.x1]="dragStartX || measurement.startX"
            [attr.y1]="dragStartY || measurement.startY"
            [attr.x2]="measurement.startX"
            [attr.y2]="measurement.startY"
            class="measure-line drag-indicator">
          </line>
        </g>
        
        <!-- End point drag indicator -->
        <g *ngIf="isDraggingPoint === 'prevEnd-' + i">
          <circle
            [attr.cx]="dragStartX || measurement.endX"
            [attr.cy]="dragStartY || measurement.endY"
            r="5"
            class="measure-point original-position">
          </circle>
          <line
            [attr.x1]="dragStartX || measurement.endX"
            [attr.y1]="dragStartY || measurement.endY"
            [attr.x2]="measurement.endX"
            [attr.y2]="measurement.endY"
            class="measure-line drag-indicator">
          </line>
        </g>
      </g>
    </svg>

    <!-- Previous measurement points - DIV-based draggable markers -->
    <div *ngFor="let measurement of previousMeasurements; let i = index">
      <!-- Start point marker -->
      <div class="measure-marker previous-start-marker"
           [class.dragging]="isDraggingPoint === 'prevStart-' + i"
           [style.left.px]="measurement.startX" 
           [style.top.px]="measurement.startY"
           (mousedown)="handlePreviousMeasurementDrag ? handlePreviousMeasurementDrag($event, i, 'start') : null">
        <div class="marker-dot"></div>
      </div>
      
      <!-- End point marker -->
      <div class="measure-marker previous-end-marker"
           [class.dragging]="isDraggingPoint === 'prevEnd-' + i"
           [style.left.px]="measurement.endX" 
           [style.top.px]="measurement.endY"
           (mousedown)="handlePreviousMeasurementDrag ? handlePreviousMeasurementDrag($event, i, 'end') : null">
        <div class="marker-dot"></div>
      </div>
      
      <!-- Circle drawing for previous measurement, if available -->
      <svg *ngIf="measurement.showCircle" class="measure-shape-container"
           [class.isDragging]="isDraggingPoint === 'prevShape-' + i"
           [attr.width]="isBrowser ? windowRef.nativeWindow.innerWidth : 0"
           [attr.height]="isBrowser ? windowRef.nativeWindow.innerHeight : 0">
        <!-- Semi-transparent overlay for the area outside the circle -->
        <defs>
          <mask id="circle-mask-{{i}}">
            <rect x="0" y="0" width="100%" height="100%" fill="white"></rect>
            <circle 
              [attr.cx]="(measurement.startX + measurement.endX) / 2" 
              [attr.cy]="(measurement.startY + measurement.endY) / 2"
              [attr.r]="calculateDistance(measurement.startX, measurement.startY, measurement.endX, measurement.endY) / 2"
              fill="black">
            </circle>
          </mask>
        </defs>
        
        <!-- This rect will darken everything except the masked circle area -->
        <rect x="0" y="0" 
              width="100%" 
              height="100%" 
              class="shape-overlay"
              [attr.mask]="'url(#circle-mask-' + i + ')'">
        </rect>
        
        <!-- The circle outline -->
        <circle 
          [attr.cx]="(measurement.startX + measurement.endX) / 2" 
          [attr.cy]="(measurement.startY + measurement.endY) / 2"
          [attr.r]="calculateDistance(measurement.startX, measurement.startY, measurement.endX, measurement.endY) / 2"
          class="measure-shape circle">
        </circle>
      </svg>
      
      <!-- Rectangle drawing for previous measurement, if available -->
      <svg *ngIf="measurement.showRectangle" class="measure-shape-container"
           [class.isDragging]="isDraggingPoint === 'prevShape-' + i"
           [attr.width]="isBrowser ? windowRef.nativeWindow.innerWidth : 0"
           [attr.height]="isBrowser ? windowRef.nativeWindow.innerHeight : 0">
        <!-- Semi-transparent overlay for the area outside the rectangle -->
        <defs>
          <mask id="rectangle-mask-{{i}}">
            <rect x="0" y="0" width="100%" height="100%" fill="white"></rect>
            <rect 
              [attr.x]="Math.min(measurement.startX, measurement.endX)" 
              [attr.y]="Math.min(measurement.startY, measurement.endY)"
              [attr.width]="Math.abs(measurement.endX - measurement.startX)"
              [attr.height]="Math.abs(measurement.endY - measurement.startY)"
              fill="black">
            </rect>
          </mask>
        </defs>
        
        <!-- This rect will darken everything except the masked rectangle area -->
        <rect x="0" y="0" 
              width="100%" 
              height="100%" 
              class="shape-overlay"
              [attr.mask]="'url(#rectangle-mask-' + i + ')'">
        </rect>
        
        <!-- Rectangle outline (this must come before the dimension lines so it doesn't cover them) -->
        <rect 
          [attr.x]="Math.min(measurement.startX, measurement.endX)" 
          [attr.y]="Math.min(measurement.startY, measurement.endY)"
          [attr.width]="Math.abs(measurement.endX - measurement.startX)"
          [attr.height]="Math.abs(measurement.endY - measurement.startY)"
          class="measure-shape rectangle">
        </rect>
        
        <!-- Width dimension label -->
        <g class="dimension-label width-label">
          <!-- Width line -->
          <line 
            [attr.x1]="Math.min(measurement.startX, measurement.endX)"
            [attr.y1]="Math.max(measurement.startY, measurement.endY) + 15"
            [attr.x2]="Math.max(measurement.startX, measurement.endX)"
            [attr.y2]="Math.max(measurement.startY, measurement.endY) + 15"
            class="dimension-line">
          </line>
          
          <!-- Dimension arrows -->
          <line 
            [attr.x1]="Math.min(measurement.startX, measurement.endX)"
            [attr.y1]="Math.max(measurement.startY, measurement.endY) + 15"
            [attr.x2]="Math.min(measurement.startX, measurement.endX) + 5"
            [attr.y2]="Math.max(measurement.startY, measurement.endY) + 10"
            class="dimension-arrow">
          </line>
          <line 
            [attr.x1]="Math.min(measurement.startX, measurement.endX)"
            [attr.y1]="Math.max(measurement.startY, measurement.endY) + 15"
            [attr.x2]="Math.min(measurement.startX, measurement.endX) + 5"
            [attr.y2]="Math.max(measurement.startY, measurement.endY) + 20"
            class="dimension-arrow">
          </line>
          
          <line 
            [attr.x1]="Math.max(measurement.startX, measurement.endX)"
            [attr.y1]="Math.max(measurement.startY, measurement.endY) + 15"
            [attr.x2]="Math.max(measurement.startX, measurement.endX) - 5"
            [attr.y2]="Math.max(measurement.startY, measurement.endY) + 10"
            class="dimension-arrow">
          </line>
          <line 
            [attr.x1]="Math.max(measurement.startX, measurement.endX)"
            [attr.y1]="Math.max(measurement.startY, measurement.endY) + 15"
            [attr.x2]="Math.max(measurement.startX, measurement.endX) - 5"
            [attr.y2]="Math.max(measurement.startY, measurement.endY) + 20"
            class="dimension-arrow">
          </line>
          
          <!-- Width text -->
          <text 
            [attr.x]="(Math.min(measurement.startX, measurement.endX) + Math.max(measurement.startX, measurement.endX)) / 2"
            [attr.y]="Math.max(measurement.startY, measurement.endY) + 30"
            text-anchor="middle"
            class="dimension-text"
            [attr.dominant-baseline]="'central'">
            {{ getHorizontalCelestialDistance(Math.min(measurement.startX, measurement.endX), Math.max(measurement.startY, measurement.endY), Math.max(measurement.startX, measurement.endX)) || (Math.round(Math.abs(measurement.endX - measurement.startX)) + ' px') }}
          </text>
        </g>
        
        <!-- Height dimension label -->
        <g class="dimension-label height-label">
          <!-- Height line -->
          <line 
            [attr.x1]="Math.max(measurement.startX, measurement.endX) + 20"
            [attr.y1]="Math.min(measurement.startY, measurement.endY)"
            [attr.x2]="Math.max(measurement.startX, measurement.endX) + 20"
            [attr.y2]="Math.max(measurement.startY, measurement.endY)"
            class="dimension-line">
          </line>
          
          <!-- Dimension arrows -->
          <line 
            [attr.x1]="Math.max(measurement.startX, measurement.endX) + 20"
            [attr.y1]="Math.min(measurement.startY, measurement.endY)"
            [attr.x2]="Math.max(measurement.startX, measurement.endX) + 15"
            [attr.y2]="Math.min(measurement.startY, measurement.endY) + 5"
            class="dimension-arrow">
          </line>
          <line 
            [attr.x1]="Math.max(measurement.startX, measurement.endX) + 20"
            [attr.y1]="Math.min(measurement.startY, measurement.endY)"
            [attr.x2]="Math.max(measurement.startX, measurement.endX) + 25"
            [attr.y2]="Math.min(measurement.startY, measurement.endY) + 5"
            class="dimension-arrow">
          </line>
          
          <line 
            [attr.x1]="Math.max(measurement.startX, measurement.endX) + 20"
            [attr.y1]="Math.max(measurement.startY, measurement.endY)"
            [attr.x2]="Math.max(measurement.startX, measurement.endX) + 15"
            [attr.y2]="Math.max(measurement.startY, measurement.endY) - 5"
            class="dimension-arrow">
          </line>
          <line 
            [attr.x1]="Math.max(measurement.startX, measurement.endX) + 20"
            [attr.y1]="Math.max(measurement.startY, measurement.endY)"
            [attr.x2]="Math.max(measurement.startX, measurement.endX) + 25"
            [attr.y2]="Math.max(measurement.startY, measurement.endY) - 5"
            class="dimension-arrow">
          </line>
          
          <!-- Height text -->
          <text 
            [attr.x]="Math.max(measurement.startX, measurement.endX) + 35"
            [attr.y]="(Math.min(measurement.startY, measurement.endY) + Math.max(measurement.startY, measurement.endY)) / 2"
            text-anchor="start"
            class="dimension-text"
            [attr.dominant-baseline]="'central'">
            {{ getVerticalCelestialDistance(Math.max(measurement.startX, measurement.endX), Math.min(measurement.startY, measurement.endY), Math.max(measurement.startY, measurement.endY)) || (Math.round(Math.abs(measurement.endY - measurement.startY)) + ' px') }}
          </text>
        </g>
      </svg>
    </div>

    <!-- Distance labels - show previous measurements -->
    <div *ngFor="let measurement of previousMeasurements; let i = index"
         class="measure-distance previous-measurement"
         [style.left.px]="measurement.midX"
         [style.top.px]="measurement.midY"
         (mouseenter)="setMouseOverUIElement(true)"
         (mouseleave)="setMouseOverUIElement(false)"
         (mousedown)="handleShapeDragStart ? handleShapeDragStart($event, i, measurement.showCircle ? 'circle' : 'rectangle') : null">
      <span class="measurement-text">{{ measurement.distance }}</span>
      
      <div class="measurement-actions">
        <button class="btn-shape-action" 
                [class.active]="measurement.showCircle"
                (click)="toggleCircle($event, i)" 
                title="{{ 'Draw circle' | translate }}">
          <fa-icon icon="circle"></fa-icon>
        </button>
        
        <button class="btn-shape-action" 
                [class.active]="measurement.showRectangle"
                (click)="toggleRectangle($event, i)" 
                title="{{ 'Draw rectangle' | translate }}">
          <fa-icon icon="square"></fa-icon>
        </button>
        
        <button *ngIf="!isDraggingPoint || !isDraggingPoint.startsWith('prev')" 
                class="btn-delete-measurement" 
                (click)="deleteMeasurement($event, i)"
                title="{{ 'Delete measurement' | translate }}">
          <fa-icon icon="times"></fa-icon>
        </button>
      </div>

      <!-- Move the measurement note below, outside the main container to avoid wrapping -->
      <div *ngIf="i === 0 && image && imageService.isPlateSolvable(image) && !hasAdvancedSolution"
           class="measurement-note-container">
        <small class="measurement-note">
          {{ 'Celestial measurements require advanced solving' | translate }}
        </small>
      </div>
    </div>

    <!-- Current measurement circle -->
    <svg *ngIf="showCurrentCircle && measureStartPoint && measureEndPoint" class="measure-shape-container"
         [class.isDragging]="isDraggingPoint === 'currentShape'"
         [attr.width]="isBrowser ? windowRef.nativeWindow.innerWidth : 0"
         [attr.height]="isBrowser ? windowRef.nativeWindow.innerHeight : 0">
      <!-- Semi-transparent overlay for the area outside the circle -->
      <defs>
        <mask id="current-circle-mask">
          <rect x="0" y="0" width="100%" height="100%" fill="white"></rect>
          <circle 
            [attr.cx]="(measureStartPoint.x + measureEndPoint.x) / 2" 
            [attr.cy]="(measureStartPoint.y + measureEndPoint.y) / 2"
            [attr.r]="calculateDistance(measureStartPoint.x, measureStartPoint.y, measureEndPoint.x, measureEndPoint.y) / 2"
            fill="black">
          </circle>
        </mask>
      </defs>
      
      <!-- This rect will darken everything except the masked circle area -->
      <rect x="0" y="0" 
            width="100%" 
            height="100%" 
            class="shape-overlay"
            mask="url(#current-circle-mask)">
      </rect>
      
      <!-- The circle outline -->
      <circle 
        [attr.cx]="(measureStartPoint.x + measureEndPoint.x) / 2" 
        [attr.cy]="(measureStartPoint.y + measureEndPoint.y) / 2"
        [attr.r]="calculateDistance(measureStartPoint.x, measureStartPoint.y, measureEndPoint.x, measureEndPoint.y) / 2"
        class="measure-shape circle current">
      </circle>
    </svg>
    
    <!-- Current measurement rectangle -->
    <svg *ngIf="showCurrentRectangle && measureStartPoint && measureEndPoint" class="measure-shape-container"
         [class.isDragging]="isDraggingPoint === 'currentShape'"
         [attr.width]="isBrowser ? windowRef.nativeWindow.innerWidth : 0"
         [attr.height]="isBrowser ? windowRef.nativeWindow.innerHeight : 0">
      <!-- Semi-transparent overlay for the area outside the rectangle -->
      <defs>
        <mask id="current-rectangle-mask">
          <rect x="0" y="0" width="100%" height="100%" fill="white"></rect>
          <rect 
            [attr.x]="Math.min(measureStartPoint.x, measureEndPoint.x)" 
            [attr.y]="Math.min(measureStartPoint.y, measureEndPoint.y)"
            [attr.width]="Math.abs(measureEndPoint.x - measureStartPoint.x)"
            [attr.height]="Math.abs(measureEndPoint.y - measureStartPoint.y)"
            fill="black">
          </rect>
        </mask>
      </defs>
      
      <!-- This rect will darken everything except the masked rectangle area -->
      <rect x="0" y="0" 
            width="100%" 
            height="100%" 
            class="shape-overlay"
            mask="url(#current-rectangle-mask)">
      </rect>
      
      <!-- Rectangle outline (this must come before the dimension lines so it doesn't cover them) -->
      <rect 
        [attr.x]="Math.min(measureStartPoint.x, measureEndPoint.x)" 
        [attr.y]="Math.min(measureStartPoint.y, measureEndPoint.y)"
        [attr.width]="Math.abs(measureEndPoint.x - measureStartPoint.x)"
        [attr.height]="Math.abs(measureEndPoint.y - measureStartPoint.y)"
        class="measure-shape rectangle current">
      </rect>
      
      <!-- Width dimension label -->
      <g class="dimension-label width-label">
        <!-- Width line -->
        <line 
          [attr.x1]="Math.min(measureStartPoint.x, measureEndPoint.x)"
          [attr.y1]="Math.max(measureStartPoint.y, measureEndPoint.y) + 15"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x)"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y) + 15"
          class="dimension-line current">
        </line>
        
        <!-- Dimension arrows -->
        <line 
          [attr.x1]="Math.min(measureStartPoint.x, measureEndPoint.x)"
          [attr.y1]="Math.max(measureStartPoint.y, measureEndPoint.y) + 15"
          [attr.x2]="Math.min(measureStartPoint.x, measureEndPoint.x) + 5"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y) + 10"
          class="dimension-arrow current">
        </line>
        <line 
          [attr.x1]="Math.min(measureStartPoint.x, measureEndPoint.x)"
          [attr.y1]="Math.max(measureStartPoint.y, measureEndPoint.y) + 15"
          [attr.x2]="Math.min(measureStartPoint.x, measureEndPoint.x) + 5"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y) + 20"
          class="dimension-arrow current">
        </line>
        
        <line 
          [attr.x1]="Math.max(measureStartPoint.x, measureEndPoint.x)"
          [attr.y1]="Math.max(measureStartPoint.y, measureEndPoint.y) + 15"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x) - 5"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y) + 10"
          class="dimension-arrow current">
        </line>
        <line 
          [attr.x1]="Math.max(measureStartPoint.x, measureEndPoint.x)"
          [attr.y1]="Math.max(measureStartPoint.y, measureEndPoint.y) + 15"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x) - 5"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y) + 20"
          class="dimension-arrow current">
        </line>
        
        <!-- Width text -->
        <text 
          [attr.x]="(Math.min(measureStartPoint.x, measureEndPoint.x) + Math.max(measureStartPoint.x, measureEndPoint.x)) / 2"
          [attr.y]="Math.max(measureStartPoint.y, measureEndPoint.y) + 30"
          text-anchor="middle"
          class="dimension-text current"
          [attr.dominant-baseline]="'central'">
          {{ getHorizontalCelestialDistance(Math.min(measureStartPoint.x, measureEndPoint.x), Math.max(measureStartPoint.y, measureEndPoint.y), Math.max(measureStartPoint.x, measureEndPoint.x)) || (Math.round(Math.abs(measureEndPoint.x - measureStartPoint.x)) + ' px') }}
        </text>
      </g>
      
      <!-- Height dimension label -->
      <g class="dimension-label height-label">
        <!-- Height line -->
        <line 
          [attr.x1]="Math.max(measureStartPoint.x, measureEndPoint.x) + 20"
          [attr.y1]="Math.min(measureStartPoint.y, measureEndPoint.y)"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x) + 20"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y)"
          class="dimension-line current">
        </line>
        
        <!-- Dimension arrows -->
        <line 
          [attr.x1]="Math.max(measureStartPoint.x, measureEndPoint.x) + 20"
          [attr.y1]="Math.min(measureStartPoint.y, measureEndPoint.y)"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x) + 15"
          [attr.y2]="Math.min(measureStartPoint.y, measureEndPoint.y) + 5"
          class="dimension-arrow current">
        </line>
        <line 
          [attr.x1]="Math.max(measureStartPoint.x, measureEndPoint.x) + 20"
          [attr.y1]="Math.min(measureStartPoint.y, measureEndPoint.y)"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x) + 25"
          [attr.y2]="Math.min(measureStartPoint.y, measureEndPoint.y) + 5"
          class="dimension-arrow current">
        </line>
        
        <line 
          [attr.x1]="Math.max(measureStartPoint.x, measureEndPoint.x) + 20"
          [attr.y1]="Math.max(measureStartPoint.y, measureEndPoint.y)"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x) + 15"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y) - 5"
          class="dimension-arrow current">
        </line>
        <line 
          [attr.x1]="Math.max(measureStartPoint.x, measureEndPoint.x) + 20"
          [attr.y1]="Math.max(measureStartPoint.y, measureEndPoint.y)"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x) + 25"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y) - 5"
          class="dimension-arrow current">
        </line>
        
        <!-- Height text -->
        <text 
          [attr.x]="Math.max(measureStartPoint.x, measureEndPoint.x) + 35"
          [attr.y]="(Math.min(measureStartPoint.y, measureEndPoint.y) + Math.max(measureStartPoint.y, measureEndPoint.y)) / 2"
          text-anchor="start"
          class="dimension-text current"
          [attr.dominant-baseline]="'central'">
          {{ getVerticalCelestialDistance(Math.max(measureStartPoint.x, measureEndPoint.x), Math.min(measureStartPoint.y, measureEndPoint.y), Math.max(measureStartPoint.y, measureEndPoint.y)) || (Math.round(Math.abs(measureEndPoint.y - measureStartPoint.y)) + ' px') }}
        </text>
      </g>
    </svg>
    
    <!-- Current measurement display -->
    <div *ngIf="measureDistance" class="measure-distance current-measurement"
         [style.left.px]="(measureStartPoint.x + measureEndPoint.x) / 2"
         [style.top.px]="(measureStartPoint.y + measureEndPoint.y) / 2"
         (mouseenter)="setMouseOverUIElement(true)"
         (mouseleave)="setMouseOverUIElement(false)"
         (mousedown)="handleCurrentShapeDragStart ? handleCurrentShapeDragStart($event, showCurrentCircle ? 'circle' : 'rectangle') : null">
      <span class="measurement-text">{{ measureDistance }}</span>
      
      <div class="measurement-actions">
        <button class="btn-shape-action" 
                [class.active]="showCurrentCircle"
                (click)="toggleCurrentCircle($event)" 
                title="{{ 'Draw circle' | translate }}">
          <fa-icon icon="circle"></fa-icon>
        </button>
        
        <button class="btn-shape-action" 
                [class.active]="showCurrentRectangle"
                (click)="toggleCurrentRectangle($event)" 
                title="{{ 'Draw rectangle' | translate }}">
          <fa-icon icon="square"></fa-icon>
        </button>
      </div>
      
      <!-- Move the measurement note below, outside the main container to avoid wrapping -->
      <div *ngIf="image && imageService.isPlateSolvable(image) && !hasAdvancedSolution"
           class="measurement-note-container">
        <small class="measurement-note">
          {{ 'Celestial measurements require advanced solving' | translate }}
        </small>
      </div>
    </div>

    <!-- Coordinate labels for previous measurements -->
    <div *ngFor="let measurement of previousMeasurements; let i = index">
      <!-- Start point coordinates with perpendicular positioning -->
      <div *ngIf="measurement.startRa !== null" class="measure-coord-label"
           [style.left.px]="measurement.startLabelX"
           [style.top.px]="measurement.startLabelY">
        <small>{{ formatCoordinatesCompact(measurement.startRa, measurement.startDec) }}</small>
      </div>

      <!-- End point coordinates with perpendicular positioning -->
      <div *ngIf="measurement.endRa !== null" class="measure-coord-label"
           [style.left.px]="measurement.endLabelX"
           [style.top.px]="measurement.endLabelY">
        <small>{{ formatCoordinatesCompact(measurement.endRa, measurement.endDec) }}</small>
      </div>
    </div>

    <!-- Overlay for capturing clicks and drags during measuring mode -->
    <div
      *ngIf="isMeasuringMode"
      class="measure-click-overlay"
      (click)="handleMeasurementClick($event)"
      (mousedown)="handleStartPointOrDrag($event)"
    ></div>
  </div>

  <!-- Coordinate display -->
  <div class="coordinates-wrapper" *ngIf="showCoordinates && mouseRa && mouseDec && !isGif"
       (mouseenter)="setMouseOverUIElement(true)"
       (mouseleave)="setMouseOverUIElement(false)">
    <astrobin-coordinates-display
      [raHtml]="mouseRa"
      [decHtml]="mouseDec"
      [galacticRaHtml]="mouseGalacticRa"
      [galacticDecHtml]="mouseGalacticDec"
      [showGalactic]="true"
      [showAttribution]="true"
    ></astrobin-coordinates-display>
  </div>

  <!-- Crosshair rulers -->
  <div
    *ngIf="
    showCoordinates &&
    mouseX !== null &&
    mouseY !== null &&
    !isGif &&
    !isMouseOverUIElement
  "
    class="crosshair-container"
  >
    <div class="crosshair-h" [style.top.px]="mouseY"></div>
    <div class="crosshair-v" [style.left.px]="mouseX"></div>
  </div>

  <ng-container
    *ngIf="{
      hd: hdThumbnail,
      real: realThumbnail
    } as thumbnails"
  >
    <ng-container
      *ngIf="touchMode && !isGif"
      [ngTemplateOutletContext]="{ hd: thumbnails.hd, real: thumbnails.real }"
      [ngTemplateOutlet]="touchDeviceTemplate"
    >
    </ng-container>

    <ng-container *ngIf="!touchMode || isGif">
      <ng-container
        [ngTemplateOutletContext]="{ hd: thumbnails.hd, real: thumbnails.real }"
        [ngTemplateOutlet]="nonTouchDeviceTemplate"
      >
      </ng-container>
    </ng-container>
  </ng-container>

  <div (click)="hide($event)" class="close" *ngIf="!isMeasuringMode"
       (mouseenter)="setMouseOverUIElement(true)"
       (mouseleave)="setMouseOverUIElement(false)">
    <fa-icon icon="down-left-and-up-right-to-center"></fa-icon>
  </div>

  <div class="astrobin-logo"
       (mouseenter)="setMouseOverUIElement(true)"
       (mouseleave)="setMouseOverUIElement(false)">
    <a routerLink="/">
      <img src="/assets/images/nav-logo.png?v=3" alt="AstroBin" />
    </a>
  </div>

  <!-- Custom Keyboard Shortcuts Overlay -->
  <div class="keyboard-shortcuts-overlay" *ngIf="showKeyboardShortcutsOverlay"
       (mouseenter)="setMouseOverUIElement(true)"
       (mouseleave)="setMouseOverUIElement(false)">
    <div class="shortcuts-header">
      <strong>{{ 'Keyboard Shortcuts' | translate }}</strong>
      <button class="btn-close-shortcuts" (click)="hideShortcutsOverlay()">
        <fa-icon icon="times"></fa-icon>
      </button>
    </div>
    <ul class="shortcuts-list">
      <li><kbd>Z</kbd> <span>{{ 'Toggle Lens/Zoom mode' | translate }}</span></li>
      <li *ngIf="hasAdvancedSolution"><kbd>C</kbd> <span>{{ 'Toggle coordinates display' | translate }}</span></li>
      <li><kbd>D</kbd> <span>{{ 'Toggle distance measuring tool' | translate }}</span></li>
      <li><kbd>F</kbd> <span>{{ 'Freeze/unfreeze zoom position' | translate }}</span></li>
      <li><kbd>ESC</kbd> <span>{{ 'Exit current mode or close image' | translate }}</span></li>
    </ul>
  </div>
</div>
