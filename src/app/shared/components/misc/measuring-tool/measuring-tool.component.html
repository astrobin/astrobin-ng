<div class="measuring-tool-container" *ngIf="active" [class.rotation-active]="isRotatingRectangle">
  <!-- Overlay for capturing clicks and drags during measuring mode -->
  <!-- Put this first so other elements can be on top of it -->
  <div class="measure-click-overlay" 
       (click)="handleMeasurementClick($event)"
       (mousedown)="handleMeasurementMouseDown($event)"></div>
       
  <!-- Start and end markers -->
  <div *ngIf="measureStartPoint" class="measure-marker start-marker"
       [class.dragging]="isDraggingPoint === 'start'"
       [style.left.px]="measureStartPoint.x" [style.top.px]="measureStartPoint.y"
       (mousedown)="handlePointDragStart($event, 'start')">
    <div class="marker-dot"></div>
    <!-- Start point coordinates with extended directional positioning -->
    <div *ngIf="!measureEndPoint" class="marker-coordinates initial-position visible"
         style="position: absolute; top: -24px; left: -24px; transform: translateX(-50%);">
      <small>{{ formatCoordinatesCompact(measureStartPoint.ra, measureStartPoint.dec) }}</small>
    </div>

    <!-- Once both points are selected, calculate perpendicular position for labels -->
    <div *ngIf="measureEndPoint" class="marker-coordinates visible"
         [style.left.px]="calculateStartLabelX()"
         [style.top.px]="calculateStartLabelY()">
      <small>{{ formatCoordinatesCompact(measureStartPoint.ra, measureStartPoint.dec) }}</small>
    </div>
  </div>

  <div *ngIf="measureEndPoint" class="measure-marker end-marker"
       [class.dragging]="isDraggingPoint === 'end'"
       [style.left.px]="measureEndPoint.x" [style.top.px]="measureEndPoint.y"
       (mousedown)="handlePointDragStart($event, 'end')">
    <div class="marker-dot"></div>
    <!-- End point coordinates perpendicular to line -->
    <div class="marker-coordinates visible"
         [style.left.px]="calculateEndLabelX()"
         [style.top.px]="calculateEndLabelY()">
      <small>{{ formatCoordinatesCompact(measureEndPoint.ra, measureEndPoint.dec) }}</small>
    </div>
  </div>

  <!-- Previous lines -->
  <svg class="measure-line-container"
       [attr.width]="windowWidth"
       [attr.height]="windowHeight">
    <!-- Previous measurements -->
    <g *ngFor="let measurement of previousMeasurements; let i = index">
      <line
        [attr.x1]="measurement.startX" [attr.y1]="measurement.startY"
        [attr.x2]="measurement.endX" [attr.y2]="measurement.endY"
        class="measure-line previous-line">
      </line>
    </g>

    <!-- Current measurement line -->
    <line *ngIf="!measureEndPoint && measureStartPoint && mouseX !== null && mouseY !== null"
          [attr.x1]="measureStartPoint.x" [attr.y1]="measureStartPoint.y"
          [attr.x2]="mouseX" [attr.y2]="mouseY"
          class="measure-line measuring"></line>
    <line *ngIf="measureEndPoint"
          [attr.x1]="measureStartPoint.x" [attr.y1]="measureStartPoint.y"
          [attr.x2]="measureEndPoint.x" [attr.y2]="measureEndPoint.y"
          class="measure-line current-line"></line>
          
    <!-- Visual indicator for original position when dragging current measurement points -->
    <g *ngIf="isDraggingPoint === 'start' && measureStartPoint">
      <circle
        [attr.cx]="dragStartX || measureStartPoint.x"
        [attr.cy]="dragStartY || measureStartPoint.y"
        r="5"
        class="measure-point original-position">
      </circle>
      <line
        [attr.x1]="dragStartX || measureStartPoint.x"
        [attr.y1]="dragStartY || measureStartPoint.y"
        [attr.x2]="measureStartPoint.x"
        [attr.y2]="measureStartPoint.y"
        class="measure-line drag-indicator">
      </line>
    </g>
    
    <g *ngIf="isDraggingPoint === 'end' && measureEndPoint">
      <circle
        [attr.cx]="dragStartX || measureEndPoint.x"
        [attr.cy]="dragStartY || measureEndPoint.y"
        r="5"
        class="measure-point original-position">
      </circle>
      <line
        [attr.x1]="dragStartX || measureEndPoint.x"
        [attr.y1]="dragStartY || measureEndPoint.y"
        [attr.x2]="measureEndPoint.x"
        [attr.y2]="measureEndPoint.y"
        class="measure-line drag-indicator">
      </line>
    </g>
    
    <!-- Visual indicators for dragging previous measurement points -->
    <g *ngFor="let measurement of previousMeasurements; let i = index">
      <!-- Start point drag indicator -->
      <g *ngIf="isDraggingPoint === 'prevStart-' + i">
        <circle
          [attr.cx]="dragStartX || measurement.startX"
          [attr.cy]="dragStartY || measurement.startY"
          r="5"
          class="measure-point original-position">
        </circle>
        <line
          [attr.x1]="dragStartX || measurement.startX"
          [attr.y1]="dragStartY || measurement.startY"
          [attr.x2]="measurement.startX"
          [attr.y2]="measurement.startY"
          class="measure-line drag-indicator">
        </line>
      </g>
      
      <!-- End point drag indicator -->
      <g *ngIf="isDraggingPoint === 'prevEnd-' + i">
        <circle
          [attr.cx]="dragStartX || measurement.endX"
          [attr.cy]="dragStartY || measurement.endY"
          r="5"
          class="measure-point original-position">
        </circle>
        <line
          [attr.x1]="dragStartX || measurement.endX"
          [attr.y1]="dragStartY || measurement.endY"
          [attr.x2]="measurement.endX"
          [attr.y2]="measurement.endY"
          class="measure-line drag-indicator">
        </line>
      </g>
    </g>
  </svg>

  <!-- Previous measurement points - DIV-based draggable markers -->
  <div *ngFor="let measurement of previousMeasurements; let i = index">
    <!-- Start point marker -->
    <div class="measure-marker previous-start-marker"
         [class.dragging]="isDraggingPoint === 'prevStart-' + i"
         [style.left.px]="measurement.startX" 
         [style.top.px]="measurement.startY"
         (mousedown)="handlePreviousMeasurementDrag($event, i, 'start')">
      <div class="marker-dot"></div>
    </div>
    
    <!-- End point marker -->
    <div class="measure-marker previous-end-marker"
         [class.dragging]="isDraggingPoint === 'prevEnd-' + i"
         [style.left.px]="measurement.endX" 
         [style.top.px]="measurement.endY"
         (mousedown)="handlePreviousMeasurementDrag($event, i, 'end')">
      <div class="marker-dot"></div>
    </div>
    
    <!-- Rotation handle for rectangle -->
    <div *ngIf="measurement.showRectangle" 
         class="measure-marker rotation-handle"
         [class.rotating]="isDraggingPoint === 'rotateRect-' + i && isRotatingRectangle"
         [style.left.px]="Math.max(measurement.startX, measurement.endX)" 
         [style.top.px]="Math.min(measurement.startY, measurement.endY)"
         (mousedown)="handleRectangleRotateStart($event, i)"
         (wheel)="handleRotationWheel($event, i)"
         title="{{ 'Rotate rectangle' | translate }}">
      <div class="rotation-icon">
        <fa-icon icon="arrows-rotate"></fa-icon>
      </div>
    </div>
    
    <!-- Circle drawing for previous measurement, if available -->
    <svg *ngIf="measurement.showCircle" class="measure-shape-container"
         [class.isDragging]="isDraggingPoint === 'prevShape-' + i"
         [attr.width]="windowWidth"
         [attr.height]="windowHeight">
      <!-- Semi-transparent overlay for the area outside the circle -->
      <defs>
        <mask id="circle-mask-{{i}}">
          <rect x="0" y="0" width="100%" height="100%" fill="white"></rect>
          <circle 
            [attr.cx]="(measurement.startX + measurement.endX) / 2" 
            [attr.cy]="(measurement.startY + measurement.endY) / 2"
            [attr.r]="calculateDistance(measurement.startX, measurement.startY, measurement.endX, measurement.endY) / 2"
            fill="black">
          </circle>
        </mask>
      </defs>
      
      <!-- This rect will darken everything except the masked circle area -->
      <rect x="0" y="0" 
            width="100%" 
            height="100%" 
            class="shape-overlay"
            [attr.mask]="'url(#circle-mask-' + i + ')'">
      </rect>
      
      <!-- The circle outline -->
      <circle 
        [attr.cx]="(measurement.startX + measurement.endX) / 2" 
        [attr.cy]="(measurement.startY + measurement.endY) / 2"
        [attr.r]="calculateDistance(measurement.startX, measurement.startY, measurement.endX, measurement.endY) / 2"
        class="measure-shape circle">
      </circle>
    </svg>
    
    <!-- Rectangle drawing for previous measurement, if available -->
    <svg *ngIf="measurement.showRectangle" class="measure-shape-container"
         [class.isDragging]="isDraggingPoint === 'prevShape-' + i"
         [attr.width]="windowWidth"
         [attr.height]="windowHeight">
      <!-- Semi-transparent overlay for the area outside the rectangle -->
      <defs>
        <mask id="rectangle-mask-{{i}}">
          <rect x="0" y="0" width="100%" height="100%" fill="white"></rect>
          <g>
            <rect 
              [attr.x]="Math.min(measurement.startX, measurement.endX)" 
              [attr.y]="Math.min(measurement.startY, measurement.endY)"
              [attr.width]="Math.abs(measurement.endX - measurement.startX)"
              [attr.height]="Math.abs(measurement.endY - measurement.startY)"
              fill="black">
            </rect>
          </g>
        </mask>
      </defs>
      
      <!-- This rect will darken everything except the masked rectangle area -->
      <rect x="0" y="0" 
            width="100%" 
            height="100%" 
            class="shape-overlay"
            [attr.mask]="'url(#rectangle-mask-' + i + ')'">
      </rect>
      
      <!-- Rectangle group without rotation transform - image rotates instead -->
      <g>
        <!-- Rectangle outline (this must come before the dimension lines so it doesn't cover them) -->
        <rect 
          [attr.x]="Math.min(measurement.startX, measurement.endX)" 
          [attr.y]="Math.min(measurement.startY, measurement.endY)"
          [attr.width]="Math.abs(measurement.endX - measurement.startX)"
          [attr.height]="Math.abs(measurement.endY - measurement.startY)"
          class="measure-shape rectangle"
          [class.rotating]="isDraggingPoint === 'rotateRect-' + i && isRotatingRectangle">
        </rect>
        
        <!-- Width dimension label (inside rotated group) -->
        <g class="dimension-label width-label">
          <!-- Width line -->
          <line 
            [attr.x1]="Math.min(measurement.startX, measurement.endX)"
            [attr.y1]="Math.max(measurement.startY, measurement.endY) + 15"
            [attr.x2]="Math.max(measurement.startX, measurement.endX)"
            [attr.y2]="Math.max(measurement.startY, measurement.endY) + 15"
            class="dimension-line">
          </line>
          
          <!-- Dimension arrows -->
          <line 
            [attr.x1]="Math.min(measurement.startX, measurement.endX)"
            [attr.y1]="Math.max(measurement.startY, measurement.endY) + 15"
            [attr.x2]="Math.min(measurement.startX, measurement.endX) + 5"
            [attr.y2]="Math.max(measurement.startY, measurement.endY) + 10"
            class="dimension-arrow">
          </line>
          <line 
            [attr.x1]="Math.min(measurement.startX, measurement.endX)"
            [attr.y1]="Math.max(measurement.startY, measurement.endY) + 15"
            [attr.x2]="Math.min(measurement.startX, measurement.endX) + 5"
            [attr.y2]="Math.max(measurement.startY, measurement.endY) + 20"
            class="dimension-arrow">
          </line>
          
          <line 
            [attr.x1]="Math.max(measurement.startX, measurement.endX)"
            [attr.y1]="Math.max(measurement.startY, measurement.endY) + 15"
            [attr.x2]="Math.max(measurement.startX, measurement.endX) - 5"
            [attr.y2]="Math.max(measurement.startY, measurement.endY) + 10"
            class="dimension-arrow">
          </line>
          <line 
            [attr.x1]="Math.max(measurement.startX, measurement.endX)"
            [attr.y1]="Math.max(measurement.startY, measurement.endY) + 15"
            [attr.x2]="Math.max(measurement.startX, measurement.endX) - 5"
            [attr.y2]="Math.max(measurement.startY, measurement.endY) + 20"
            class="dimension-arrow">
          </line>
          
          <!-- Width text -->
          <text 
            [attr.x]="(Math.min(measurement.startX, measurement.endX) + Math.max(measurement.startX, measurement.endX)) / 2"
            [attr.y]="Math.max(measurement.startY, measurement.endY) + 30"
            text-anchor="middle"
            class="dimension-text"
            [attr.dominant-baseline]="'central'">
            {{ getHorizontalCelestialDistance(Math.min(measurement.startX, measurement.endX), Math.max(measurement.startY, measurement.endY), Math.max(measurement.startX, measurement.endX)) || (Math.round(Math.abs(measurement.endX - measurement.startX)) + ' px') }}
          </text>
        </g>
        
        <!-- Height dimension label (inside rotated group) -->
        <g class="dimension-label height-label">
          <!-- Height line -->
          <line 
            [attr.x1]="Math.max(measurement.startX, measurement.endX) + 20"
            [attr.y1]="Math.min(measurement.startY, measurement.endY)"
            [attr.x2]="Math.max(measurement.startX, measurement.endX) + 20"
            [attr.y2]="Math.max(measurement.startY, measurement.endY)"
            class="dimension-line">
          </line>
          
          <!-- Dimension arrows -->
          <line 
            [attr.x1]="Math.max(measurement.startX, measurement.endX) + 20"
            [attr.y1]="Math.min(measurement.startY, measurement.endY)"
            [attr.x2]="Math.max(measurement.startX, measurement.endX) + 15"
            [attr.y2]="Math.min(measurement.startY, measurement.endY) + 5"
            class="dimension-arrow">
          </line>
          <line 
            [attr.x1]="Math.max(measurement.startX, measurement.endX) + 20"
            [attr.y1]="Math.min(measurement.startY, measurement.endY)"
            [attr.x2]="Math.max(measurement.startX, measurement.endX) + 25"
            [attr.y2]="Math.min(measurement.startY, measurement.endY) + 5"
            class="dimension-arrow">
          </line>
          
          <line 
            [attr.x1]="Math.max(measurement.startX, measurement.endX) + 20"
            [attr.y1]="Math.max(measurement.startY, measurement.endY)"
            [attr.x2]="Math.max(measurement.startX, measurement.endX) + 15"
            [attr.y2]="Math.max(measurement.startY, measurement.endY) - 5"
            class="dimension-arrow">
          </line>
          <line 
            [attr.x1]="Math.max(measurement.startX, measurement.endX) + 20"
            [attr.y1]="Math.max(measurement.startY, measurement.endY)"
            [attr.x2]="Math.max(measurement.startX, measurement.endX) + 25"
            [attr.y2]="Math.max(measurement.startY, measurement.endY) - 5"
            class="dimension-arrow">
          </line>
          
          <!-- Height text -->
          <text 
            [attr.x]="Math.max(measurement.startX, measurement.endX) + 35"
            [attr.y]="(Math.min(measurement.startY, measurement.endY) + Math.max(measurement.startY, measurement.endY)) / 2"
            text-anchor="start"
            class="dimension-text"
            [attr.dominant-baseline]="'central'">
            {{ getVerticalCelestialDistance(Math.max(measurement.startX, measurement.endX), Math.min(measurement.startY, measurement.endY), Math.max(measurement.startY, measurement.endY)) || (Math.round(Math.abs(measurement.endY - measurement.startY)) + ' px') }}
          </text>
        </g>
        
        <!-- Removing SVG rotation handle (using DOM-based version instead) -->
        <g class="rotate-handle rotation-master-handle-placeholder"></g>
      </g>
    </svg>
  </div>

  <!-- Distance labels - show previous measurements -->
  <div *ngFor="let measurement of previousMeasurements; let i = index"
       class="measure-distance previous-measurement"
       [style.left.px]="measurement.midX"
       [style.top.px]="measurement.midY"
       (mouseenter)="setMouseOverUIElement(true)"
       (mouseleave)="setMouseOverUIElement(false)"
       (mousedown)="handleShapeDragStart($event, i, measurement.showCircle ? 'circle' : 'rectangle')">
    <span class="measurement-text">{{ measurement.distance }}</span>
    
    <div class="measurement-actions">
      <button type="button" class="btn-shape-action circle-button" 
              [class.active]="measurement.showCircle"
              (click)="toggleCircle($event, i)" 
              (mousedown)="$event.stopPropagation()"
              (pointerdown)="$event.stopPropagation()"
              title="{{ 'Draw circle' | translate }}">
        <fa-icon icon="circle"></fa-icon>
      </button>
      
      <button type="button" class="btn-shape-action rectangle-button" 
              [class.active]="measurement.showRectangle"
              (click)="toggleRectangle($event, i)" 
              (mousedown)="$event.stopPropagation()"
              (pointerdown)="$event.stopPropagation()"
              title="{{ 'Draw rectangle' | translate }}">
        <fa-icon icon="square"></fa-icon>
      </button>
      
      <button type="button" *ngIf="!isDraggingPoint || !isDraggingPoint.startsWith('prev')" 
              class="btn-delete-measurement delete-button" 
              (click)="deleteMeasurement($event, i)"
              (mousedown)="$event.stopPropagation()"
              (pointerdown)="$event.stopPropagation()"
              title="{{ 'Delete measurement' | translate }}">
        <fa-icon icon="times"></fa-icon>
      </button>
    </div>
  </div>

  <!-- Current measurement circle -->
  <svg *ngIf="showCurrentCircle && measureStartPoint && measureEndPoint" class="measure-shape-container"
       [class.isDragging]="isDraggingPoint === 'currentShape'"
       [attr.width]="windowWidth"
       [attr.height]="windowHeight">
    <!-- Semi-transparent overlay for the area outside the circle -->
    <defs>
      <mask id="current-circle-mask">
        <rect x="0" y="0" width="100%" height="100%" fill="white"></rect>
        <circle 
          [attr.cx]="(measureStartPoint.x + measureEndPoint.x) / 2" 
          [attr.cy]="(measureStartPoint.y + measureEndPoint.y) / 2"
          [attr.r]="calculateDistance(measureStartPoint.x, measureStartPoint.y, measureEndPoint.x, measureEndPoint.y) / 2"
          fill="black">
        </circle>
      </mask>
    </defs>
    
    <!-- This rect will darken everything except the masked circle area -->
    <rect x="0" y="0" 
          width="100%" 
          height="100%" 
          class="shape-overlay"
          mask="url(#current-circle-mask)">
    </rect>
    
    <!-- The circle outline -->
    <circle 
      [attr.cx]="(measureStartPoint.x + measureEndPoint.x) / 2" 
      [attr.cy]="(measureStartPoint.y + measureEndPoint.y) / 2"
      [attr.r]="calculateDistance(measureStartPoint.x, measureStartPoint.y, measureEndPoint.x, measureEndPoint.y) / 2"
      class="measure-shape circle current">
    </circle>
  </svg>
  
  <!-- Current measurement rectangle -->
  <svg *ngIf="showCurrentRectangle && measureStartPoint && measureEndPoint" class="measure-shape-container"
       [class.isDragging]="isDraggingPoint === 'currentShape'"
       [attr.width]="windowWidth"
       [attr.height]="windowHeight">
    <!-- Semi-transparent overlay for the area outside the rectangle -->
    <defs>
      <mask id="current-rectangle-mask">
        <rect x="0" y="0" width="100%" height="100%" fill="white"></rect>
        <g>
          <rect 
            [attr.x]="Math.min(measureStartPoint.x, measureEndPoint.x)" 
            [attr.y]="Math.min(measureStartPoint.y, measureEndPoint.y)"
            [attr.width]="Math.abs(measureEndPoint.x - measureStartPoint.x)"
            [attr.height]="Math.abs(measureEndPoint.y - measureStartPoint.y)"
            fill="black">
          </rect>
        </g>
      </mask>
    </defs>
    
    <!-- This rect will darken everything except the masked rectangle area -->
    <rect x="0" y="0" 
          width="100%" 
          height="100%" 
          class="shape-overlay"
          mask="url(#current-rectangle-mask)">
    </rect>
    
    <!-- Rectangle group without rotation transform - image rotates instead -->
    <g>
      <!-- Rectangle outline (this must come before the dimension lines so it doesn't cover them) -->
      <rect 
        [attr.x]="Math.min(measureStartPoint.x, measureEndPoint.x)" 
        [attr.y]="Math.min(measureStartPoint.y, measureEndPoint.y)"
        [attr.width]="Math.abs(measureEndPoint.x - measureStartPoint.x)"
        [attr.height]="Math.abs(measureEndPoint.y - measureStartPoint.y)"
        class="measure-shape rectangle current"
        [class.rotating]="isDraggingPoint === 'rotateCurrentRect' && isRotatingRectangle">
      </rect>

      <!-- Width dimension label -->
      <g class="dimension-label width-label">
        <!-- Width line -->
        <line 
          [attr.x1]="Math.min(measureStartPoint.x, measureEndPoint.x)"
          [attr.y1]="Math.max(measureStartPoint.y, measureEndPoint.y) + 15"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x)"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y) + 15"
          class="dimension-line current">
        </line>
        
        <!-- Dimension arrows -->
        <line 
          [attr.x1]="Math.min(measureStartPoint.x, measureEndPoint.x)"
          [attr.y1]="Math.max(measureStartPoint.y, measureEndPoint.y) + 15"
          [attr.x2]="Math.min(measureStartPoint.x, measureEndPoint.x) + 5"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y) + 10"
          class="dimension-arrow current">
        </line>
        <line 
          [attr.x1]="Math.min(measureStartPoint.x, measureEndPoint.x)"
          [attr.y1]="Math.max(measureStartPoint.y, measureEndPoint.y) + 15"
          [attr.x2]="Math.min(measureStartPoint.x, measureEndPoint.x) + 5"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y) + 20"
          class="dimension-arrow current">
        </line>
        
        <line 
          [attr.x1]="Math.max(measureStartPoint.x, measureEndPoint.x)"
          [attr.y1]="Math.max(measureStartPoint.y, measureEndPoint.y) + 15"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x) - 5"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y) + 10"
          class="dimension-arrow current">
        </line>
        <line 
          [attr.x1]="Math.max(measureStartPoint.x, measureEndPoint.x)"
          [attr.y1]="Math.max(measureStartPoint.y, measureEndPoint.y) + 15"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x) - 5"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y) + 20"
          class="dimension-arrow current">
        </line>
        
        <!-- Width text -->
        <text 
          [attr.x]="(Math.min(measureStartPoint.x, measureEndPoint.x) + Math.max(measureStartPoint.x, measureEndPoint.x)) / 2"
          [attr.y]="Math.max(measureStartPoint.y, measureEndPoint.y) + 30"
          text-anchor="middle"
          class="dimension-text current"
          [attr.dominant-baseline]="'central'">
          {{ getHorizontalCelestialDistance(Math.min(measureStartPoint.x, measureEndPoint.x), Math.max(measureStartPoint.y, measureEndPoint.y), Math.max(measureStartPoint.x, measureEndPoint.x)) || (Math.round(Math.abs(measureEndPoint.x - measureStartPoint.x)) + ' px') }}
        </text>
      </g>

      <!-- Height dimension label -->
      <g class="dimension-label height-label">
        <!-- Height line -->
        <line 
          [attr.x1]="Math.max(measureStartPoint.x, measureEndPoint.x) + 20"
          [attr.y1]="Math.min(measureStartPoint.y, measureEndPoint.y)"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x) + 20"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y)"
          class="dimension-line current">
        </line>
        
        <!-- Dimension arrows -->
        <line 
          [attr.x1]="Math.max(measureStartPoint.x, measureEndPoint.x) + 20"
          [attr.y1]="Math.min(measureStartPoint.y, measureEndPoint.y)"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x) + 15"
          [attr.y2]="Math.min(measureStartPoint.y, measureEndPoint.y) + 5"
          class="dimension-arrow current">
        </line>
        <line 
          [attr.x1]="Math.max(measureStartPoint.x, measureEndPoint.x) + 20"
          [attr.y1]="Math.min(measureStartPoint.y, measureEndPoint.y)"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x) + 25"
          [attr.y2]="Math.min(measureStartPoint.y, measureEndPoint.y) + 5"
          class="dimension-arrow current">
        </line>
        
        <line 
          [attr.x1]="Math.max(measureStartPoint.x, measureEndPoint.x) + 20"
          [attr.y1]="Math.max(measureStartPoint.y, measureEndPoint.y)"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x) + 15"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y) - 5"
          class="dimension-arrow current">
        </line>
        <line 
          [attr.x1]="Math.max(measureStartPoint.x, measureEndPoint.x) + 20"
          [attr.y1]="Math.max(measureStartPoint.y, measureEndPoint.y)"
          [attr.x2]="Math.max(measureStartPoint.x, measureEndPoint.x) + 25"
          [attr.y2]="Math.max(measureStartPoint.y, measureEndPoint.y) - 5"
          class="dimension-arrow current">
        </line>
        
        <!-- Height text -->
        <text 
          [attr.x]="Math.max(measureStartPoint.x, measureEndPoint.x) + 35"
          [attr.y]="(Math.min(measureStartPoint.y, measureEndPoint.y) + Math.max(measureStartPoint.y, measureEndPoint.y)) / 2"
          text-anchor="start"
          class="dimension-text current"
          [attr.dominant-baseline]="'central'">
          {{ getVerticalCelestialDistance(Math.max(measureStartPoint.x, measureEndPoint.x), Math.min(measureStartPoint.y, measureEndPoint.y), Math.max(measureStartPoint.y, measureEndPoint.y)) || (Math.round(Math.abs(measureEndPoint.y - measureStartPoint.y)) + ' px') }}
        </text>
      </g>
      
      <!-- Removing SVG rotation handle (using DOM-based version instead) -->
      <g class="rotate-handle rotation-master-handle-placeholder"></g>
    </g>
  </svg>
  
  <!-- Current measurement display -->
  <div *ngIf="measureDistance" class="measure-distance current-measurement"
       [style.left.px]="(measureStartPoint.x + measureEndPoint.x) / 2"
       [style.top.px]="(measureStartPoint.y + measureEndPoint.y) / 2"
       (mouseenter)="setMouseOverUIElement(true)"
       (mouseleave)="setMouseOverUIElement(false)"
       (mousedown)="handleCurrentShapeDragStart($event, showCurrentCircle ? 'circle' : 'rectangle')">
    <span class="measurement-text">{{ measureDistance }}</span>
    
    <div class="measurement-actions">
      <button type="button" class="btn-shape-action circle-button" 
              [class.active]="showCurrentCircle"
              (click)="toggleCurrentCircle($event)" 
              (mousedown)="$event.stopPropagation()"
              (pointerdown)="$event.stopPropagation()"
              title="{{ 'Draw circle' | translate }}">
        <fa-icon icon="circle"></fa-icon>
      </button>
      
      <button type="button" class="btn-shape-action rectangle-button" 
              [class.active]="showCurrentRectangle"
              (click)="toggleCurrentRectangle($event)" 
              (mousedown)="$event.stopPropagation()"
              (pointerdown)="$event.stopPropagation()"
              title="{{ 'Draw rectangle' | translate }}">
        <fa-icon icon="square"></fa-icon>
      </button>
    </div>
  </div>

  <!-- Current rotation handle as a DOM element -->
  <div *ngIf="showCurrentRectangle && measureStartPoint && measureEndPoint" 
       class="measure-marker rotation-handle current"
       [class.rotating]="isDraggingPoint === 'rotateCurrentRect' && isRotatingRectangle"
       [style.left.px]="Math.max(measureStartPoint.x, measureEndPoint.x)" 
       [style.top.px]="Math.min(measureStartPoint.y, measureEndPoint.y)"
       (mousedown)="handleRectangleRotateStart($event)"
       (wheel)="handleRotationWheel($event)"
       title="{{ 'Rotate rectangle' | translate }}">
    <div class="rotation-icon">
      <fa-icon icon="arrows-rotate"></fa-icon>
    </div>
  </div>

  <!-- Coordinate labels for previous measurements -->
  <div *ngFor="let measurement of previousMeasurements; let i = index">
    <!-- Start point coordinates with perpendicular positioning -->
    <div class="measure-coord-label visible"
         [style.left.px]="measurement.startLabelX"
         [style.top.px]="measurement.startLabelY">
      <small>{{ formatCoordinatesCompact(measurement.startRa, measurement.startDec) }}</small>
    </div>

    <!-- End point coordinates with perpendicular positioning -->
    <div class="measure-coord-label visible"
         [style.left.px]="measurement.endLabelX"
         [style.top.px]="measurement.endLabelY">
      <small>{{ formatCoordinatesCompact(measurement.endRa, measurement.endDec) }}</small>
    </div>
  </div>

  <!-- Measuring tool controls -->
  <div class="measuring-controls-right">
    <button class="btn btn-sm btn-outline-light me-2" (click)="clearAllMeasurements()"
            *ngIf="previousMeasurements.length > 0">
      <fa-icon icon="trash" class="me-1"></fa-icon>
      {{ 'Clear all' | translate }}
    </button>
    <button class="btn btn-sm btn-outline-light" (click)="exitMeasuring()">
      <fa-icon icon="times" class="me-1"></fa-icon>
      {{ 'Exit measuring tool' | translate }}
    </button>
  </div>

</div>